# 析构函数可以抛出异常么

**面试官：** 你在项目里遇到过析构函数抛异常的情况吗？你觉得C++析构函数能不能抛出异常？

**求职者：** 其实这个问题挺有意思的。理论上，C++的析构函数是可以抛出异常的，因为析构函数本质上就是一个普通成员函数嘛，语法上没有限制你throw。但实际上，析构函数抛异常是非常危险的，尤其是在栈展开（stack unwinding）过程中。

**面试官：** 为什么说危险？能具体说说吗？

**求职者：** 主要是因为C++异常机制的规则：C++不允许同时存在两个未处理的异常。具体场景为一个异常抛出时，程序会进行栈展开以销毁从异常点到catch点的所有局部变量。栈展开时会使用析构函数来清理局部变量，如果此时局部变量的析构函数也抛出了异常，这时就会存在两个未处理的异常。程序会直接调用`std::terminate()`，导致崩溃。

**面试官：** 那如果析构函数里真的有可能出错怎么办？

**求职者：** 最好的做法是：
1. 尽量不要在析构函数里抛异常。
2. 如果析构函数里有可能出错，可以用try-catch把异常吃掉，或者把错误信息记录下来，千万别让异常跑出析构函数。
3. 如果资源释放可能失败，建议提供一个专门的`close()`或`release()`方法，让用户手动处理异常。

**面试官：** 你能举个例子说明下吗？

**求职者：** 比如说你有个类负责文件操作，析构时要关闭文件。如果关闭文件可能失败，最好不要在析构函数里直接throw，而是catch住异常，或者让用户自己调用`close()`方法并处理异常。

让我们通过一个小练习来理解析构函数抛异常的风险和正确做法：[析构函数抛异常练习](../../MyOutput/02-C++object/CodeOut/destructor_throw/destructor_throw_demo.cpp)

---

> 代码练习：请在`MyOutput/02-C++object/CodeOut/destructor_throw/destructor_throw_demo.cpp`中，按如下TODO任务逐步完成：
> 1. 定义一个类`FileHandler`，在析构函数中模拟抛出异常。
> 2. 在main函数中创建`FileHandler`对象，并观察异常传播。
> 3. 修改析构函数，使用try-catch捕获异常，避免异常逃逸。
> 4. 增加一个`close()`成员函数，模拟资源释放失败时抛异常，并在main中手动调用并catch。
> 5. 总结析构函数抛异常的风险和最佳实践。

> 答案参考见：[Solution/destructor_throw_demo.cpp](../../MyOutput/02-C++object/CodeOut/destructor_throw/Solution/destructor_throw_demo.cpp)

