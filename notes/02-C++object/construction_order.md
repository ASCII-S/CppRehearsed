# 类对象的初始化和析构顺序详解

**面试官：** 我们来聊聊C++中类对象的初始化和析构顺序，这可是面试高频考点。你能说说对象的构造和析构顺序吗？

**候选人：** 当然可以！其实这个问题看似简单，细节还挺多的。我们可以分几种典型场景来聊：

---

### 1. 普通成员变量的初始化顺序

**面试官：** 如果一个类有多个成员变量，它们的初始化顺序是怎样的？

**候选人：** 这个顺序其实和你在类里**声明的顺序**有关，而不是你在构造函数初始化列表里的顺序。比如：

```cpp
class Demo {
    A a;
    B b;
public:
    Demo() : b(), a() {}
};
```

虽然初始化列表里`b`在前，`a`在后，但实际初始化顺序是先`a`后`b`，因为它们在类中声明时`a`在前。

---

### 2. 继承关系下的构造和析构顺序

**面试官：** 那如果有继承关系呢？

**候选人：** 继承时，**先构造基类，再构造派生类**。析构顺序正好相反，**先析构派生类，再析构基类**。如果成员里还有其他类对象，顺序是：

1. 先构造基类
2. 再构造成员对象（按声明顺序）
3. 最后构造派生类自身

析构时顺序完全反过来。

---

### 3. 全局、局部和静态对象的构造析构顺序

**面试官：** 全局对象、局部对象、静态对象的构造析构顺序有啥不同？

**候选人：**
- **全局对象**：在main函数前构造，程序结束后析构。
- **局部对象**：进入作用域时构造，离开作用域时析构。
- **静态局部对象**：第一次执行到定义语句时构造，程序结束时析构。

---

### 4. 高频面试追问

**面试官：** 如果成员变量的声明顺序和初始化列表顺序不一致，会有啥坑？

**候选人：** 这会导致你以为先初始化了b，实际却是先初始化a，可能引发依赖顺序的bug。编译器一般会有warning提醒。

**面试官：** 派生类的成员对象和基类对象，谁先构造？

**候选人：** 一定是**基类先构造**，然后成员对象，最后派生类本身。

**面试官：** 析构顺序呢？

**候选人：** 完全反过来，先析构派生类本身，再析构成员对象，最后析构基类。

---

### 5. 代码演示与实操

想更直观理解这些顺序？可以参考这个代码练习：

> [类对象初始化和析构顺序演示](../../MyOutput/02-C++object/CodeOut/construction_order/construction_order_demo.cpp)

**动手练习指引：**
- 代码文件中会以TODO序号引导你逐步补全，建议控制在30分钟内完成。
- 完成后可对照答案：
> [参考答案](../../MyOutput/02-C++object/CodeOut/construction_order/Solution/construction_order_demo.cpp)

---

**总结：**
- 成员变量按声明顺序初始化
- 先基类，后成员，最后派生类本身
- 析构顺序正好反过来
- 注意初始化列表顺序和声明顺序不一致的坑

面试遇到这类问题，记得结合代码举例，条理清晰地讲出来，面试官会很喜欢！
