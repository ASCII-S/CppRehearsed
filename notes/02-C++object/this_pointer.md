# this指针

面试官：说说你对 this 指针的理解吧。

好的，this 指针其实是 C++ 面向对象编程中一个很重要的概念。简单来说，this 指针就是指向当前对象的指针，它是每个非静态成员函数都有的一个隐含参数。

面试官：能具体说说 this 指针有什么特点吗？

当然可以。this 指针有几个重要特点：

首先，this 指针是一个常指针，它的类型是 `T* const this`，也就是说 this 指针本身不能被修改，但它指向的对象内容可以被修改。

其次，this 指针是隐式传递的。当我们调用一个非静态成员函数时，编译器会自动把当前对象的地址作为 this 指针传递给函数。

还有一点很重要，静态成员函数是没有 this 指针的，因为静态成员函数不属于任何特定的对象实例。

面试官：那什么时候需要显式使用 this 指针呢？

这个问题很实际！主要有这几种情况：

第一种是当参数名和成员变量名冲突的时候。比如在构造函数或成员函数中，参数名和成员变量同名，这时候就需要用 this 指针来区分。

第二种是实现链式调用。当我们希望成员函数返回当前对象的引用，以便连续调用多个成员函数时，就需要 `return *this`。

第三种是在自赋值的情况下。比如在赋值操作符重载中，我们通常要检查是否是自己给自己赋值，这时候就要比较 `this` 和参数的地址。

第四种是在回调函数中，有时候需要把当前对象的指针传递给其他函数。

面试官：能举个实际的例子吗？

当然，让我通过代码来演示这些用法：

[this指针使用演示](../../MyOutput/02-C++object/CodeOut/this_pointer/this_pointer_demo.cpp)

面试官：刚才你提到了链式调用，这在实际开发中有什么好处？

链式调用最大的好处就是让代码更加简洁和直观。比如在设计类似构建器模式的类时，可以这样写：
```cpp
builder.setName("张三").setAge(25).setCity("北京").build();
```

这种写法比分别调用多个函数要清晰很多。另外像 STL 中的流操作符重载也大量使用了这种技术，比如 `cout << "hello" << " world" << endl`。

面试官：那 this 指针在继承中有什么需要注意的地方吗？

这是个很好的问题！在继承关系中，this 指针始终指向==最终的对象类型==。

比如说，如果我们有一个基类 Base 和派生类 Derived，当我们通过 Derived 对象调用基类的成员函数时，基类函数中的 this 指针实际上指向的是 Derived 对象，而不是 Base 对象。

这也是为什么虚函数能够正确工作的原因之一。通过 this 指针，基类的虚函数能够访问到正确的虚函数表，从而调用到派生类中重写的函数。

面试官：最后问一个，this 指针可以是空指针吗？

理论上来说，this 指针不应该是空指针，因为成员函数总是通过有效的对象来调用的。但是在一些特殊情况下，比如通过空指针调用成员函数，this 可能会是空的。

不过这种情况是未定义行为，应该避免。在实际编程中，如果怀疑 this 可能为空，可以在函数开始时进行检查，但这通常表明设计上有问题。

现代 C++ 中，我们更推荐使用引用而不是指针来避免这类问题，或者使用智能指针来管理对象的生命周期。

总的来说，this 指针是 C++ 面向对象编程的基石之一，理解它的工作原理对于写出高质量的 C++ 代码非常重要。

